Java parte 3: Entendendo herança e interface

Para mais teoria : https://www.w3schools.com/java/default.asp

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Sobre a herança de classes, todas as afirmativas abaixo são verdadeiras, exceto:

Alternativa correta
Quando uma classe herda de outra, ela recebe também seus construtores automaticamente.

Não é verdade, pois recebe apenas seus métodos e atributos. Lembra-se não tem herança de construtores

prendemos que a construção de um objeto é baseada em seu(s) construtor(es).
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Qual das alternativas abaixo é a correta?

Alternativa correta
O construtor default do java deixa de existir a partir do momento que algum é declarado na classe.


Correto, assim que criarmos o nosso próprio construtor, o construtor default (sem parâmetros) deixa de existir, No entanto, nada impede adicionar o construtor default explicitamente.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Na última aula vimos sobre a anotação @Override. Qual a finalidade dela?

Alternativa correta
É usada para sobrescrever o método da classe mãe, indicando que o método original foi alterado.

exemplo de uma reescrita de um metodo.

O benefício da substituição é: capacidade de definir um comportamento específico ao tipo de subclasse, o que significa que uma subclasse pode 
implementar um método de classe pai com base em seus requisitos.

Em termos orientados a objetos, substituir significa substituir a funcionalidade de um método existente.

Exemplo
Vamos ver um exemplo.

Demonstração ao vivo
class Animal {
   public void move() {
      System.out.println("Animals can move");
   }
}

class Dog extends Animal {
   public void move() {
      System.out.println("Dogs can walk and run");
   }
}

public class TestDog {

   public static void main(String args[]) {
      Animal a = new Animal();   // Animal reference and object
      Animal b = new Dog();   // Animal reference but Dog object

      a.move();   // runs the method in Animal class
      b.move();   // runs the method in Dog class
   }
}
Isso produzirá o seguinte resultado -

Resultado
Animals can move
Dogs can walk and run
No exemplo acima, você pode ver que, embora b seja um tipo de Animal, ele executa o método move na classe Dog. A razão para isso é: No tempo de compilação, 
a verificação é feita no tipo de referência. No entanto, no tempo de execução, a JVM descobre o tipo de objeto e executa o 
método que pertence a esse objeto específico.

Portanto, no exemplo acima, o programa será compilado corretamente, pois a classe Animal tem o método mover. Em seguida, 
no tempo de execução, ele executa o método específico para esse objeto

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Nessa aula, vimos:

Conceitos de herança, construtores e polimorfismo
A utilização da anotação @Override
Construtores não são herdados
Um construtor da classe mãe pode ser chamado através do super()
No próximo video vamos falar como se comportam classes e métodos abstratos! Aguarde :)










